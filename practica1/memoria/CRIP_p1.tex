\documentclass[12pt, spanish]{article}
\usepackage[spanish]{babel}
\selectlanguage{spanish}
%\usepackage{natbib}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{multirow}
\usepackage{float}
\usepackage{chngpage}
\usepackage{enumitem}
\usepackage{forloop}


\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage{subcaption}

\usepackage{hyperref}
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
]{doclicense}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

% para codigo
\usepackage{listings}
\usepackage{xcolor}


\usepackage[default]{sourcesanspro}

\setmarginsrb{2 cm}{1 cm}{2 cm}{2 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\title{Práctica 1:\\
Aritmética modular.\hspace{0.05cm} }
\author{Antonio David Villegas Yeguas}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}


\usepackage{caption}

\lstset{
language=C++,
basicstyle=\small\ttfamily,
numbers=left,
numbersep=5pt,
xleftmargin=20pt,
frame=tb,
framexleftmargin=20pt
}


\DeclareCaptionFormat{mylst}{\hrule#2#3}
\captionsetup[lstlisting]{format=mylst,labelfont=bf,singlelinecheck=off,labelsep=space}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
    \centering
    \vspace*{0.3 cm}
    \includegraphics[scale = 0.50]{ugr.png}\\[0.7 cm]
    %\textsc{\LARGE Universidad de Granada}\\[2.0 cm]
    \textsc{\large 4º CSI 2020/21}\\[0.5 cm]
    \textsc{\large Grado en Ingeniería Informática}\\[0.5 cm]
    \rule{\linewidth}{0.2 mm} \\[0.2 cm]
    { \huge \bfseries \thetitle}\\
    \rule{\linewidth}{0.2 mm} \\[1 cm]

    \begin{minipage}{0.4\textwidth}
        \begin{flushleft} \large
            \emph{Autor:}\\
            \theauthor\\
			 \emph{DNI:}\\
            77021623-M
            \end{flushleft}
            \end{minipage}~
            \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
            \emph{Asignatura: \\
            Criptografía}   \\
            \emph{Correo:}\\
            advy99@correo.ugr.es
        \end{flushright}
    \end{minipage}\\[0.5cm]

    {\large \thedate}\\[0.5cm]
    {\url{https://github.com/advy99/CRIP/}}
    {\doclicenseThis}

    \vfill

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section*{Introducción}

En esta práctica repasaremos conceptos de las asignaturas Álgebra Lineal y Métodos Discretos y Lógica y Métodos Discretos de cara a implementar algoritmos que nos permitan trabajar en anillos y cuerpos de $\mathbb{Z}$.

\section{Algoritmo extendido de Euclides}

En este primer ejercicio se nos pide implementar el algoritmo extendido de Euclides. Este algoritmo nos permitirá obtener el máximo común divisor de dos números que recibirá como entrada.

Este algoritmo se basa en ir realizando divisiones sucesivas hasta obtener un cero, y el último resto distinto de cero será el máximo común divisor. Además, también obtendremos un $s$ y un $t$, tal que si buscamos el máximo común divisor de $a$ y $b$, $mcd(a, b) = a \cdot s + b \cdot t$.

La implementación es la siguiente:

\begin{lstlisting}[caption={Algoritmo extendido de Euclides}]
INPUT: a, b
OUTPUT: r <- mcd(a,b), s, t

Si a == 0 o b == 0
	Devolver vacio

r0 <- a
r1 <- b
s0 <- 1
s1 <- 0
t0 <- 0
t1 <- 1

Mientras r1 != 0:
	q <- r0 / r1
	r0, r1 <- r1, r0 - r1 * q
	s0, s1 <- s1, s0 - s1 * q
	t0, t1 <- t1, t0 - t1 * q

Devolver r0, s0, t0
\end{lstlisting}

Como vemos, el algoritmo se basa en ir dividiendo $a$ por $b$, y actualizar sus valores, $a$ pasa a valer $b$, y $b$ el residuo de la división. De esta forma, cuando $b$ llegue a cero, $a$ valdrá el residuo anterior, que será el máximo común divisor.

En $s$ y $t$ iremos almacenando los valores de la identidad de Bezout de cara a tener los coeficientes con los que se puede expresar el máximo común divisor.


\section{Inverso modular de dos primos relativos}

Para este ejercicio vamos a calcular el inverso de un número $a$ módulo $b$, siendo $a$ y $b$ dos primos relativos.

Si $a$ y $b$ son primos resativos, su máximo común divisor vale uno, por lo que sabemos por la identidad de Bezout que:

$$ mcd(a, b) = 1 = u \cdot a + v \cdot b $$

Y también sabemos que estamos trabajando en los restos de dividir por $b$, es decir $\mathbb{Z}_b$, luego:

$$1 = u \cdot a + v \cdot b $$
$$1 = u \cdot a $$
$$a^{-1} = u$$

Ya que en $\mathbb{Z}_b$ el valor de $b$ es cero. De esta forma, con el algoritmo extendido de Euclides y sabiendo que $a$ y $b$ son primos relativos podemos obtener el inverso de $a$ módulo $b$.

En este caso utilizamos el algoritmo del ejercicio anterior, usando el segundo valor devuelto, el de $s$. También podríamos volverlo a escribir sin calcular $t$, ya que no es necesario para el cálculo.


\section{Potencia modular}

Ahora se nos pide implementar un algoritmo de forma que calculemos $a^b \mod n$ para cualquier $a$, $b$ y $n$ enteros positivos.

Este ejercicio parece simple a primera vista, pero el problema es que si se tratan de valores excesivamente grandes la operación normal de exponenciación no es suficiente, ya que desbordaría los registros y memoria de la máquina.

Para evitar esto, sabiendo que vamos a trabajar en $\mathbb{Z}_{n}$, la idea es aprovechar la representación binaria del exponente para saber cuando tenemos que multiplicar el resultado por la base, y al utilizar representación binaria, cada vez que desplacemos un bit del exponente, elevar al cuadrado la base, de forma que la operación sea equivalente.

\newpage

\begin{lstlisting}[caption={Algoritmo de exponenciación modular}]
INPUT: base, exponente, modulo
OUTPUT: resultado <- (base^exponente) mod modulo

resultado <- 1

Mientras exponente > 0:
	Si el bit menos significativo del exponente == 1:
		resultado <- (resultado * base) mod modulo

	exponente <- exponente desplazando su valor un bit a la derecha
	base <- (base * base) mod modulo

Devolver resultado
\end{lstlisting}


\section{Test de Miller-Rabin}

El test de Miller-Rabin se trata de un test de primalidad con una tasa de acierto del 75\% si el resultado es que el número es primo y determinista si el número no es primo. Además cada ejecución es independiente por lo que podemos lanzar el test multiples veces y si las pasa todas, podemos asegurar con una probabilidad muy alta que un número es primo.

Este test se basa en dos ideas:

\begin{enumerate}
	\item Si $p$ es un número primo, $\mathbb{Z}_p$ es un cuerpo, por lo que $x^2 - 1 = 0$ tiene solo dos raices (test de Fermat).
	\item Si para un $a$ tal que $a \neq 0$ entonces $a^{-1} = 1$ en $\mathbb{Z}_p$.
\end{enumerate}

Si $p$ es par y distinto de dos, rápidamente podemos responder que no es primo.

Este test no funciona para primos por debajo de cinco, aunque no supone un problema ya que podemos tratar ese caso particular.

El test se basa en descomponer $p - 1$ como $2^u \cdot s$ con $s$ impar, escoger una semilla aleatoria $a$ tal que $1 < a < p - 1$ y con esa semilla obtener la siguiente lista $L$:

$$L = {a^s, a^{2 \cdot s}, a^{2^2 \cdot s}, ..., a^{2^{u - 1} \cdot s}, a^{2^{u} \cdot s}}$$

De esta forma, podrían darse los siguientes casos:

\begin{enumerate}
	\item Que la primera potencia $a^s$ valga $1$ o $p - 1$, entonces $p$ \textbf{podría ser primo}.
	\item Que ningun elemento de $L$ sea uno, luego no superaría el test de Fermat, y $p$ \textbf{no es primo}.
	\item Que encontremos una potencia que valga uno, sin que esté precedida de una potencia que valga menos uno. En este caso $p$ \textbf{no es primo}, ya que hemos encontrado una raiz que no es ni uno ni menos uno en $\mathbb{Z}_p$.
	\item Que encontremos una potencia que valga menos uno, luego la siguiente valdrá uno, y por lo tanto $p$ \textbf{podría ser primo}.
\end{enumerate}

Como vemos, en cualquier momento que encontremos un uno o menos uno podemos parar el algoritmo, y no es necesario calcular la lista completa. Otro detalle a tener en cuenta en la implementación es que no es necesario calcular cada valor independiente de la lista, un valor se obtiene como el cuadrado del anterior.

\begin{lstlisting}[caption={Test de Miller-Rabin}]
INPUT: p
OUTPUT: verdadero si p podria ser primo, falso si no lo es

resultado <- falso

Si p <= 5:
	resultado <- numero == 2 o numero == 3 o numero == 5
si no:
	Si p es par:
		resultado <- falso
	Si no:
		Descomponemos p - 1 como 2^u * s (almacenamos u y s)
		a <- aleatorio entre 2 y p - 1
		a <- a^s mod p

		resultado <- a == 1 o a == p - 1
		continuar <- !resultado

		Para i = 1 hasta i < u Y continuar:
			a <- a^2 mod p

			Si a == p - 1:
				resultado <- verdadero
				continuar <- falso

			Si a == 1
				resultado <- falso
				continuar <- falso

			i <- i + 1

Devolver resultado
\end{lstlisting}

Como he comentado, este test nos dice si $p$ es primo un 75\% de probabilidad de acertar en caso positivo. Como cada ejecución es independiente y si responde que no es primo, sabemos con certeza que no lo es, podemos ejecutar diez veces el test para comprobar si es primo, lo que nos daría una probabilidad de acierto del $99'9999046\%$.

De esta forma, nuestra función de si un número es primo sería la siguiente:

\begin{lstlisting}[caption={Función para comprobar si un numero es primo}]
INPUT: p
OUTPUT: verdadero si p es un pseudoprimo, falso si no lo es

resultado <- verdadero

i <- 0

Mientras i < 10 Y resultado:
	resultado = resultado Y test_miller_rabin(p)
	i <- i +1

Devolver resultado
\end{lstlisting}

También podemos tener una función que nos diga el siguiente primo dado un número, comprobando si el siguiente impar es primo, y si no lo es, sumando dos. Si el número inicial es par, le restamos uno para que al sumar dos nos de el siguiente impar.

\begin{lstlisting}[caption={Función para encontrar el siguiente primo}]
INPUT: p
OUTPUT: resultado <- siguiente primo a p

resultado <- p

Si p es par:
	resultado <- resultado - 1

Hacer:
	resultado <- resultado + 2
Mientras !es_primo(resultado)

Devolver resultado
\end{lstlisting}


\section{Logaritmo discreto}

\section{Raices cuadradas modulares}

\subsection{Raiz cuadrada modular}

\subsection{Obtener todas las raices}


\section{Métodos de factorización}

\subsection{Factorización utilizando el método de Fermat}

\subsection{Factorización utilizando el algoritmo de $\rho$ de Pollard}



\section{Comparación de tiempos}


% \begin{thebibliography}{9}
%
%
% \end{thebibliography}

\end{document}
